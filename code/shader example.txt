
========================================
E:\soon\projects\PBNPR\resource\source_examples\export_folder_tree_to_txt.py
========================================
import os

# Define which file extensions to include
INCLUDE_EXTENSIONS = {'.py', '.glsl', '.txt', '.md'}

# Output file name
OUTPUT_FILE = 'combined_output.txt'

def collect_files(base_dir):
    """Recursively collect files with target extensions."""
    collected = []
    for root, _, files in os.walk(base_dir):
        for file in files:
            if os.path.splitext(file)[1] in INCLUDE_EXTENSIONS:
                collected.append(os.path.join(root, file))
    return collected

def write_combined_output(files, output_path):
    """Write contents of all files into one output file."""
    with open(output_path, 'w', encoding='utf-8') as out:
        for file_path in files:
            out.write(f"\n{'='*40}\n{file_path}\n{'='*40}\n")
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    out.write(f.read())
            except Exception as e:
                out.write(f"[Error reading {file_path}: {e}]\n")

if __name__ == "__main__":
    current_dir = os.path.dirname(os.path.abspath(__file__))
    subfolder = os.path.join(current_dir)  # or specify a subfolder like 'src'
    files = collect_files(subfolder)
    write_combined_output(files, os.path.join(current_dir, OUTPUT_FILE))
    print(f"âœ… Combined {len(files)} files into {OUTPUT_FILE}")

========================================
E:\soon\projects\PBNPR\resource\source_examples\shader_dot\frag.glsl
========================================
/*with:-
uColor
uPP
uVIEWm:
    uOBJm
    uCAMm
uPROJm
in vec3 V_N;
*/
void main() {
    //vec3 worldNormal = normalize(mat3(uVIEWm.OBJ) * V_N);
    //
    //float Dot = dot(uPP,worldNormal);
    //
    //fragColor = uColor * vec4(vec3(Dot),1.0);
    fragColor = vec4(1.0);
}
========================================
E:\soon\projects\PBNPR\resource\source_examples\shader_dot\shader_dot.py
========================================
# This file belongs to S00N's PBNPR Blender Add-on
# all rights reserved (C) 2024 S00N
#========================WARNING=================================
#Important!: This file is a template for shader integration.
# the name of this file (shaderNameMe.py) must be changed to the desired shader name when copied.
# MUST BE UNIQUE TO NOT INTERFIER WITH PYTHON MODULES AND OTHER SHADERS IN THE STREAM.
# BE AWARE all python files have the same access to any thing in bpy module, so name collisions may occur.
#========================IMPORTS=================================
import os
import bpy
import gpu
from gpu_extras.batch import batch_for_shader
from dataclasses import dataclass
from typing import Callable, Type
import numpy as np
try:
    from ....code.bpy_glsl_manager import gpu_types as t
    from ....code.bpy_glsl_manager.GLSLbase import _get_mesh_data_for_gpu,_define_type_source,UBO
except:
    from bpy_glsl_manager import gpu_types as t # pyright: ignore[reportMissingImports]
    from bpy_glsl_manager.GLSLbase import _get_mesh_data_for_gpu, _define_type_source,UBO # pyright: ignore[reportMissingImports]
#=====================__FILE__ CONSTANTS===========================
BASE_DIR     = os.path.dirname(__file__)
ABS_DIR      = os.path.abspath(__file__)
SHADER_NAME  = os.path.splitext(os.path.basename(ABS_DIR))[0]
V            = os.path.join(BASE_DIR, t.SHADER_V)
F            = os.path.join(BASE_DIR, t.SHADER_F)
DRAW_REGION  = t.SHADER_DRAW_REGION_WINDOW
DRAW_TYPE    = t.SHADER_DRAW_TYPE_POST_VIEW
DRAW_PRIMITIVE_METHOD = t.PRIM_TRIS

#=====================UI EXPOSURE===========================
def bake_toggle(self, context):
    if not self.bake:
        return
    try:
        img = self.target_img
        if not img: return

        W, H   = img.size
        # Access the stream (assuming it was initialized in your manager)
        desc, shader = bpy.gl_stream[SHADER_NAME]
        
        batch  = desc.CALL_BATCH(shader, self)
        offscreen = gpu.types.GPUOffScreen(W, H) 

        with offscreen.bind():
            gpu.state.viewport_set(0, 0, W, H)
            # Clear is recommended in 5.0.1 to avoid artifacts
            fbo = gpu.state.active_framebuffer_get()
            fbo.clear(color=(0.0, 0.0, 0.0, 0.0))
            
            desc.CALL_EXEC(shader, batch, self)
            buffer = fbo.read_color(0, 0, W, H, 4, 0, 'FLOAT')

        buffer.dimensions = W * H * 4 
        img.pixels.foreach_set(buffer) 
        img.update() 
        
        offscreen.free()
    except Exception as e:
        print(f"[SHADER OFFSCREEN BAKING REPORT]: failed at {SHADER_NAME} : {e}")
    self.bake = False
class shader_params(bpy.types.PropertyGroup):
    #Customs
    Colour : bpy.props.FloatVectorProperty(
        name="Color",subtype='COLOR', default=(0.0, 0.0, 0.0, 1.0), min=0.0, max=1.0,
        description="Color to use in the shader", size=4
    ) # pyright: ignore[reportInvalidTypeForm]
    Source: bpy.props.FloatVectorProperty(
        subtype="XYZ",size=4
    ) # pyright: ignore[reportInvalidTypeForm]
    target_obj: bpy.props.PointerProperty(
        name="",
        type=bpy.types.Object,
        description="Pick an object to use its coordinates in the shader"
    ) # pyright: ignore[reportInvalidTypeForm]
    # Sarder params
    bake : bpy.props.BoolProperty(default=False,update=bake_toggle) # pyright: ignore[reportInvalidTypeForm]
    target_img: bpy.props.PointerProperty(
        name="Target Image",
        type=bpy.types.Image
    ) # pyright: ignore[reportInvalidTypeForm]
    expand_sets: bpy.props.BoolProperty(default=True) # pyright: ignore[reportInvalidTypeForm]
    alwyas_on_top: bpy.props.BoolProperty(
        name="Always on Top (X-Ray)", 
        default=False, 
        description="Disable depth testing to see through solids"
    ) # pyright: ignore[reportInvalidTypeForm]
    blend_mode: bpy.props.EnumProperty(
        name="Blend Mode",
        items=[
            (t.BLEND_NONE,      "Opaque",         "Solid object"),
            (t.BLEND_ALPHA,     "Alpha Blend",    "Standard transparency"),
            (t.BLEND_ADD,       "Additive",       "Glowing/Hologram style"),
            (t.BLEND_ADD_ALPHA, "Additive Alpha", "Additive but respects alpha"),
            (t.BLEND_MULTIPLY,  "Multiply",       "Darkening, good for shadows")
        ],
        default=t.BLEND_NONE
    ) # pyright: ignore[reportInvalidTypeForm]
    depth_mode: bpy.props.EnumProperty(
        name="Depth Mode",
        items=[
            (t.DEPTH_NONE,    "None",       "No depth testing, draw on top of everything"),
            (t.DEPTH_ALWAYS,  "Always",     "Draw regardless of depth, but still write to depth buffer"),
            (t.DEPTH_LESS,    "Less",       "Standard: Draw if closer than existing pixels"),
            (t.DEPTH_LEQUAL,  "Less Equal", "Draw if closer or equal (Default)"),
            (t.DEPTH_GREATER, "Greater",    "Draw if further away than existing pixels"),
            (t.DEPTH_GEQUAL,  "Greater Equal","Draw if further or equal")
        ],
        default=t.DEPTH_LEQUAL
    ) # pyright: ignore[reportInvalidTypeForm]
    cull_mode: bpy.props.EnumProperty(
        name="Cull Mode",
        items=[
            (t.CULL_NONE,   "None",   "No culling"),
            (t.CULL_FRONT,  "Front",  "Cull front faces"),
            (t.CULL_BACK,   "Back",   "Cull back faces (Default)")
        ],
        default=t.CULL_BACK
    ) # pyright: ignore[reportInvalidTypeForm]

def specify_ui_in_panel(
        panel : bpy.types.Panel, 
        ui : shader_params
    ):
    box = panel.layout.box()
    col = box.column(align=True)
    # List all of the shader_params items, the ui is also customized

    col.prop(ui, "Colour")
    col.prop(ui, "Source")
    col.prop(ui, "target_obj")
    row = box.row()
    row.prop(ui,"bake",icon='SCENE',text='')
    row.prop(ui,"target_img",icon_only=True)
    col = box.column(align=True)
    col.prop(ui, "expand_sets", 
        icon='TRIA_DOWN' if ui.expand_sets else 'TRIA_RIGHT',
        text="settings"
    )
    if ui.expand_sets:
        col.prop(ui, "alwyas_on_top")
        col.prop(ui, "blend_mode")
        col.prop(ui, "depth_mode")
        col.prop(ui, "cull_mode")

#======================LOCALE SHADER INTERFACE==============================
#interface
i_name = 'INTERFACE_C'
OUT_N  = 'V_N'
#uniform - constant
U_COLOR= 'uColor'
U_P_Pos= 'uPP'
#UBO_MAT_CO 
M_OBJ  = 'OBJ'
M_CAM  = 'CAM'
M_PROJ = 'PROJ'
# extra if needed
UBO_VIEW = UBO('uVIEWm','U_VIEW_MAT')
#======================COMPILE INTERFACE==============================
def createInfo():
    info = gpu.types.GPUShaderCreateInfo()
    #=== VARS - OBJs ===
    # Vert
    info.vertex_in(0,    t.VEC3, t.ATTR_POS)
    info.vertex_in(1,    t.VEC3, t.ATTR_NORMAL)
    #interface = gpu.types.GPUStageInterfaceInfo(i_name)
    #interface.flat(t.VEC3,OUT_N)
    #info.vertex_out(interface)
    #frag
    info.fragment_out(0, t.VEC4, t.ATTR_OUT_FRAG_COLOR)
    # Glob
    info.push_constant(t.VEC4, U_COLOR)
    info.push_constant(t.VEC3, U_P_Pos)
    
    info.typedef_source(
        _define_type_source(
            f'layout(std140) uniform {UBO_VIEW.type_name} ',
            {
                t.MAT4 : M_OBJ,
                t.MAT4 : M_CAM,
                t.MAT4 : M_PROJ
            }
        )
    )
    info.uniform_buf(2, UBO_VIEW.type_name,UBO_VIEW.name)
    
    #=== SHADERS =====
    with open(V, "r", encoding="utf-8") as f: 
        vert_src = f.read()
    with open(F, "r", encoding="utf-8") as f:
        frag_src = f.read()

    info.vertex_source(vert_src)
    info.fragment_source(frag_src)
    return info

#======================FUNCTIONALITY================================
def uniforms_bind(
        shader: gpu.types.GPUShader, 
        ui: shader_params
    ):
    # ================== CONST =====================
    uVals = {
        U_COLOR:  ui.Colour, 
        U_P_Pos : ui.Source,
    }
    for K,V in uVals.items():
        shader.uniform_float(K,V)

    # ================== UBO_VIEW ===================
    obj  = ui.target_obj
    if not obj: return
    cam  = bpy.context.scene.camera
    if not cam: return
    deps = bpy.context.evaluated_depsgraph_get()
    w,h  = [bpy.context.scene.render.resolution_x,bpy.context.scene.render.resolution_y]
    
    uValM = {
        M_OBJ  :   np.array(obj.matrix_world.transposed(),                      dtype=np.float32 ).flatten(),
        M_CAM  :   np.array(cam.matrix_world.inverted().transposed(),           dtype=np.float32 ).flatten(),
        M_PROJ :   np.array(cam.calc_matrix_camera(deps,x=w,y=h).transposed(),  dtype=np.float32 ).flatten(),
    }
    data = np.concatenate(x for x in uValM.values())
    
    global UBO_VIEW
    UBO_VIEW.buf.update(data=data)
    shader.uniform_block(UBO_VIEW.name, UBO_VIEW.buf)
    return

def batch_make(
        shader: gpu.types.GPUShader, 
        ui: shader_params
    ):
    i,P,N = _get_mesh_data_for_gpu(ui.target_obj)
    # Attribute name 'pos' must be registered in CreateInfo
    return batch_for_shader(
        shader, 
        DRAW_PRIMITIVE_METHOD, 
        {
            t.ATTR_POS   :P,
            t.ATTR_NORMAL:N
        },
        indices=i
    )

def safe_exec(
        shader: gpu.types.GPUShader, 
        batch: gpu.types.GPUBatch, 
        ui: shader_params
    ):
    gpu.state.blend_set(ui.blend_mode)
    gpu.state.depth_test_set(ui.depth_mode)
    gpu.state.face_culling_set(ui.cull_mode)

    shader.bind()
    uniforms_bind(shader, ui)
    batch.draw(shader)
    
    gpu.state.blend_set(t.BLEND_NONE)
    gpu.state.depth_test_set(t.DEPTH_NONE)
    gpu.state.face_culling_set(t.CULL_NONE)

#=================== 5.0.1 REGISTRATION (CreateInfo) =============================
def register():
    try:
        info = createInfo()
        shader = gpu.shader.create_from_info(info)
    except Exception as e:
        print(f"[ERORR AT COMPILING SHADER FROM INFO] at {SHADER_NAME}: {e}]")
    
    bpy.utils.register_class(shader_params)
        
    return shader

def unregister():
    global UBO_1
    UBO_1 = None # Explicitly release UBO
    bpy.utils.unregister_class(shader_params)

#===========================================================
@dataclass
class ShaderDesc:
    NAME: str
    PATH_VERT: str
    PATH_FRAG: str
    DRAW_REGION: str
    DRAW_TYPE: str
    DRAW_PRIMITIVE_METHOD:str
    CALL_UNI: Callable
    CALL_BATCH: Callable
    CALL_EXEC: Callable
    CALL_REG:Callable
    CALL_UNREG:Callable
    UI: Type
    CALL_UI_SPEC:Callable
DESCRIPTION = ShaderDesc(
    NAME                  = SHADER_NAME,
    PATH_VERT             = V,
    PATH_FRAG             = F,
    DRAW_REGION           = DRAW_REGION, 
    DRAW_TYPE             = DRAW_TYPE, 
    DRAW_PRIMITIVE_METHOD = DRAW_PRIMITIVE_METHOD,
    CALL_UNI              = uniforms_bind,
    CALL_BATCH            = batch_make,
    CALL_EXEC             = safe_exec,
    CALL_REG              = register,
    CALL_UNREG            = unregister,
    UI                    = shader_params,
    CALL_UI_SPEC          = specify_ui_in_panel
)
========================================
E:\soon\projects\PBNPR\resource\source_examples\shader_dot\vert.glsl
========================================
/*with:-
uColor
uPP
uVIEWm:
    uOBJm
    uCAMm
    uPROJm
V_N
in vec3 pos
in vec3 normal
*/

out vec3 V_N;
void main() {
    //OUT
    V_N = normal;
    //VIEW_marix
    vec4 viewPos = uVIEWm.CAM * uVIEWm.OBJ * vec4(pos, 1.0);
    //Depth = -viewPos.z;
    
    //outptu
    gl_Position = uVIEWm.PROJ * viewPos;
}