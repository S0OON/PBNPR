
========================================
D:\soon\projects\PBNPR\code\export_folder_tree_to_txt.py
========================================
import os

# Define which file extensions to include
INCLUDE_EXTENSIONS = {'.py', '.glsl', '.txt', '.md'}

# Output file name
OUTPUT_FILE = 'combined_output.txt'

def collect_files(base_dir):
    """Recursively collect files with target extensions."""
    collected = []
    for root, _, files in os.walk(base_dir):
        for file in files:
            if os.path.splitext(file)[1] in INCLUDE_EXTENSIONS:
                collected.append(os.path.join(root, file))
    return collected

def write_combined_output(files, output_path):
    """Write contents of all files into one output file."""
    with open(output_path, 'w', encoding='utf-8') as out:
        for file_path in files:
            out.write(f"\n{'='*40}\n{file_path}\n{'='*40}\n")
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    out.write(f.read())
            except Exception as e:
                out.write(f"[Error reading {file_path}: {e}]\n")

if __name__ == "__main__":
    current_dir = os.path.dirname(os.path.abspath(__file__))
    subfolder = os.path.join(current_dir)  # or specify a subfolder like 'src'
    files = collect_files(subfolder)
    write_combined_output(files, os.path.join(current_dir, OUTPUT_FILE))
    print(f"âœ… Combined {len(files)} files into {OUTPUT_FILE}")

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\main.py
========================================


def main():
    import sys
    import importlib
    project_root = r"D:\soon\projects\PBNPR\code\bpy_glsl_manager"

    if project_root not in sys.path:
        sys.path.append(project_root)
    
    from bpy_gl import GLSLbase
    from bpy_ui import ui_tab as UI
    
    modules= [
        GLSLbase,
        UI
    ]
    for mod in modules:
        importlib.reload(mod)

    GLSLbase.register()
    UI.register()

if __name__ == "__main__":
    main()

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\bpy_gl\GLSLbase.py
========================================
import bpy

#Hot~
def load_modules()->list:
    from src.template import template as GLSL_TEMP
    from src.paint_obj import paint as GLSL_PAINT_OBJ
    
    return[
        GLSL_TEMP,
        GLSL_PAINT_OBJ
    ]

def init_stream():
    if not hasattr(
            bpy,"gl_stream"
        ):
        bpy.gl_stream = {}

def load_mods_to_stream():
    from importlib import reload
    mods = load_modules()
    for mod in mods:
        reload(mod)
        bpy.gl_stream[mod.SHADER_NAME]=[
            mod.DESCRIPTION,None
        ]

def load_shader(name:str):
    bpy.gl_stream[name][0].CALL_REG()

def register():
    init_stream()
    load_mods_to_stream()
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\bpy_ui\ui_tab.py
========================================
import bpy

ID_OP_ADD = "gl.add_instance"
ID_OP_REMOVE = "gl.remove_instance"
ID_INSTANCE_enable = "enabled"
ID_INSTANCE_expand = "expanded"

def _get_GPU():
    from bpy_gl import GLSLbase
    return GLSLbase
GPUobjs = []
# ---------------------------------------------------------
def toggle(self, context):
    GL = _get_GPU()
    GL.load_shader(self.shaderType)

    if self.enabled and self.handler_id == -1:
        i=0
        for d in bpy.context.scene.gl_stack:
            if self == d:
                self.handler_id = i
                break
            else:
                i+=1

        while GPUobjs.__len__() <= self.handler_id:
            GPUobjs.append(None)

        pair = bpy.gl_stream[self.shaderType]
        shader = pair[1]
        desc = pair[0]
        ui_spec = getattr(
            self, 
            self.shaderType, 
            None
        )

        args = (
            shader,
            desc.CALL_BATCH(shader,ui_spec),
            ui_spec
        )

        handler = bpy.types.SpaceView3D.draw_handler_add(
            desc.CALL_EXEC, args,
            desc.DRAW_REGION, desc.DRAW_TYPE
        )
        GPUobjs[self.handler_id]=handler
    
    elif not self.enabled and self.handler_id != -1:
        pair = bpy.gl_stream[self.shaderType]
        desc = pair[0]
        bpy.types.SpaceView3D.draw_handler_remove(
            GPUobjs[self.handler_id], desc.DRAW_REGION
        )
        GPUobjs[self.handler_id] = None
        self.handler_id = -1

class gl_instance_sk(bpy.types.PropertyGroup):
    shaderType: bpy.props.StringProperty(name="shader", default="")
    enabled: bpy.props.BoolProperty(default=False, update=toggle)
    expanded: bpy.props.BoolProperty(default=True)
    handler_id : bpy.props.IntProperty(default=-1)

#-------------------------------------------------------------

def get_items(self, context):
    return [(key, key, "") for key in bpy.gl_stream.keys()]
class gl_OP_add_instance(bpy.types.Operator):
    bl_idname = ID_OP_ADD
    bl_label = "Add GLSL Instance"

    selected_type: bpy.props.EnumProperty(
        name="shaders",
        items=get_items
    )

    def invoke(self, context, event):
            wm = context.window_manager
            return wm.invoke_props_dialog(self)

    def execute(self, context):
        new_i = context.scene.gl_stack.add()
        new_i.shaderType = self.selected_type
        return {'FINISHED'}

class gl_OP_remove_instance(bpy.types.Operator):
    bl_idname = ID_OP_REMOVE
    bl_label = ""
    index_i : bpy.props.IntProperty(default=-1)

    def execute(self, context):
        if self.index_i < 0:
            return {'CANCELED'}
        x = bpy.context.scene.gl_stack[self.index_i]
        x.enabled = False
        bpy.context.scene.gl_stack.remove(self.index_i)
        return {'FINISHED'}
#-------------------------------------------------------------
class gl_panel(bpy.types.Panel):
    bl_label = "GLSL"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'GLSL manager'

    def draw(self, context):
        layout = self.layout

        box = layout.box()
        row = box.row(align=True)

        row.operator(ID_OP_ADD, text="Add Instance")

        i = 0
        for item in context.scene.gl_stack:
            box = layout.box()
            row = box.row(align=True)
            
            row.prop(item, ID_INSTANCE_expand,
                icon='TRIA_DOWN' if item.expanded else 'TRIA_RIGHT',
                icon_only=True, emboss=False
            )
            row.label(text=item.shaderType, 
                icon='SHADING_RENDERED')
            row.prop(item, ID_INSTANCE_enable, text="")
            
            op_R = row.operator(ID_OP_REMOVE, 
                              text="", icon='X')
            op_R.index_i = i # Index Save

            if not item.expanded:
                continue

            custom_params = getattr(item,item.shaderType)
            for prop in custom_params.bl_rna.properties:
                row=box.row(align=True)
                row.prop(custom_params,prop.identifier)
            i+=1

classes = [
    gl_instance_sk, 
    gl_OP_add_instance,
    gl_OP_remove_instance,
    gl_panel
]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    for pair in bpy.gl_stream.values():
        desc = pair[0]
        bpy.utils.register_class(desc.PARAMS)
        setattr(
            gl_instance_sk, desc.NAME,
            bpy.props.PointerProperty(type=desc.PARAMS)
        )
    bpy.types.Scene.gl_stack = bpy.props.CollectionProperty(type=gl_instance_sk)

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\paint_obj\frag.glsl
========================================
in vec3 v_world_pos;

uniform vec3 uColor;
uniform float uLight;
uniform vec3 uLightPos;


void main() {
    float d = distance(v_world_pos, uLightPos);
    
    // Example: Make it darker as it gets further away
    float intensity = 1.0 / (d * d + 1.0); 
    gl_FragColor = vec4(vec3(uColor*intensity*uLight), 1.0);
}
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\paint_obj\paint.py
========================================
import os
import bpy
import gpu
from gpu_extras.batch import batch_for_shader
from dataclasses import dataclass
from typing import Callable, Type
import numpy as np
from mathutils import Matrix

BASE_DIR = os.path.dirname(__file__)
SHADER_NAME = "PAINT_OBJ"
V = "vert.glsl"
F = "frag.glsl"
DRAW_REGION = "WINDOW"
DRAW_TYPE = "POST_VIEW"
DRAW_PRIMITIVE_METHOD = "TRIS"
# ------------------ ------------------ -----------

class shader_params(bpy.types.PropertyGroup):
    cam_name: bpy.props.StringProperty(default="Camera")
    obj_name: bpy.props.StringProperty(default="Cube")
    Point_name: bpy.props.StringProperty(default="Point")
    color: bpy.props.FloatVectorProperty( 
        name="Color", 
        subtype='COLOR', 
        size=4, min=0.0, max=1.0, 
        default=(0.2, 0.6, 1.0, 1.0) 
        ) 

def uniforms_bind(
        shader: gpu.types.GPUShader,
        block:shader_params
    ):
    shader.bind()

    dep = bpy.context.evaluated_depsgraph_get() 
    obj = bpy.data.objects[block.obj_name]
    obj_eval = obj.evaluated_get(dep)
    cam = bpy.data.objects[block.cam_name]

    matObj = obj_eval.matrix_world
    matCam = cam.matrix_world.inverted()

    # Projection Matrix logic
    width  = bpy.context.region.width if bpy.context.region else 1.0
    height = bpy.context.region.height if bpy.context.region else 1.0
    proj   = cam.calc_matrix_camera(dep, x=width, y=height)

    shader.uniform_float("uModel", matObj)
    shader.uniform_float("uView",  matCam)
    shader.uniform_float("uProj",  proj)
    
    obj_eval.to_mesh_clear()
    #PointLight-----------------------------------------------------------------
    shader.uniform_float("uLight", bpy.data.lights[block.Point_name].energy)
    shader.uniform_float("uLightPos", bpy.data.objects[block.Point_name].location)
    #col -----------------------------------------------------------------------
    x = [block.color[0], block.color[1], block.color[2]]
    shader.uniform_float("uColor", x)
    
def batch_make(
        shader: gpu.types.GPUShader,
        block:shader_params, 
        drawShape: str = DRAW_PRIMITIVE_METHOD
    ):
    if block.obj_name not in bpy.data.objects:
        # Fallback 2D Triangle
        coords = np.array([
                (-0.5, -0.5, 0.0), 
                (0.5, -0.5, 0.0), 
                (0.0, 0.5, 0.0)], 
                dtype=np.float32
            )
        return batch_for_shader(shader, drawShape, {"pos": coords})
    
    deps = bpy.context.evaluated_depsgraph_get()
    obj = bpy.data.objects[block.obj_name]
    obj_eval = obj.evaluated_get(deps)
    mesh = obj_eval.to_mesh()
    mesh.calc_loop_triangles()

    # Get Vertices
    vertices = np.empty((len(mesh.vertices), 3), 'f')
    mesh.vertices.foreach_get("co", vertices.reshape(-1))

    # Get Triangle Indices (Crucial for a Cube)
    indices = np.empty((len(mesh.loop_triangles), 3), 'i')
    mesh.loop_triangles.foreach_get("vertices", indices.reshape(-1))

    obj_eval.to_mesh_clear()
    
    # Pass both pos and indices to the batch
    return batch_for_shader(shader, drawShape, {"pos": vertices}, indices=indices)

def exec(
        shader: gpu.types.GPUShader,
        batch: gpu.types.GPUBatch,
        block:shader_params
    ):
    #Provided that, shader+batch
    shader.bind()
    uniforms_bind(shader,block)
    batch.draw(shader)

#-------------------------------------

def compile_n_register():
    """
    Compiles a shader, saves tp bpy.gl_stream[1] after refreshing the whole key-value
    """
    stream = bpy.gl_stream[SHADER_NAME]
    if stream[1] is not None:
        return #already compiled
    Desc = stream[0]

    with open(Desc.PATH_VERT, "r", encoding="utf-8") as f: 
        vert_src = f.read()
    with open(Desc.PATH_FRAG, "r", encoding="utf-8") as f:
        frag_src = f.read()
    shader = gpu.types.GPUShader(vert_src, frag_src)
    
    bpy.gl_stream[SHADER_NAME][1] = shader

def unregister():
    bpy.gl_descs.pop(SHADER_NAME)

@dataclass
class ShaderDesc:
    NAME: str
    PATH_VERT: str
    PATH_FRAG: str
    DRAW_REGION: str
    DRAW_TYPE: str
    DRAW_PRIMITIVE_METHOD:str
    CALL_UNI: Callable
    CALL_BATCH: Callable
    CALL_EXEC: Callable
    PARAMS: Type
    CALL_REG:Callable
    CALL_UNREG:Callable
DESCRIPTION = ShaderDesc(
    NAME                  =SHADER_NAME,
    PATH_VERT             =os.path.join(BASE_DIR, V),
    PATH_FRAG             =os.path.join(BASE_DIR, F),
    DRAW_REGION           = DRAW_REGION, 
    DRAW_TYPE             = DRAW_TYPE, 
    DRAW_PRIMITIVE_METHOD = DRAW_PRIMITIVE_METHOD,
    CALL_UNI              =uniforms_bind,
    CALL_BATCH            =batch_make,
    CALL_EXEC             =exec,
    PARAMS                =shader_params,
    CALL_REG              =compile_n_register,
    CALL_UNREG            =unregister
)

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\paint_obj\vert.glsl
========================================
in vec3 pos;
uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProj;

out vec3 v_world_pos; // Send this to fragment shader

void main() {
    vec4 world_pos = uModel * vec4(pos, 1.0);
    v_world_pos = world_pos.xyz;
    
    gl_Position = uProj * uView * world_pos;
}
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\template\frag.glsl
========================================
uniform float u_f;
out vec4 fragCol;

void main() {
    vec3 F = vec3(u_f);
    fragCol = vec4(F, 1.0);
}
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\template\template.py
========================================
import os
import bpy
import gpu
from gpu_extras.batch import batch_for_shader
from dataclasses import dataclass
from typing import Callable, Type

BASE_DIR = os.path.dirname(__file__)
SHADER_NAME = "TEMPLATE"
V = "vert.glsl"
F = "frag.glsl"
DRAW_REGION = "WINDOW"
DRAW_TYPE = "POST_VIEW"
DRAW_PRIMITIVE_METHOD = "TRIS"
# ------------------ ------------------ -----------

class shader_params(bpy.types.PropertyGroup):
    intensity: bpy.props.FloatProperty(default=1.0)

def uniforms_bind(
        shader: gpu.types.GPUShader,
        block:shader_params
    ):
    shader.bind()
    shader.uniform_float("u_f", block.intensity)

def batch_make(
        shader: gpu.types.GPUShader,
        block:shader_params, 
        drawShape: str = DRAW_PRIMITIVE_METHOD
    ):
    coords = [ 
        (-0.5, -0.5), 
        ( 0.5, -0.5), 
        ( 0.0, 0.5)
        ]
    return batch_for_shader(shader, drawShape, {"pos": coords})

def exec(
        shader: gpu.types.GPUShader,
        batch: gpu.types.GPUBatch,
        block:shader_params
    ):
    #Provided that, shader+batch
    shader.bind()
    uniforms_bind(shader,block)
    batch.draw(shader)

#-------------------------------------

def compile_n_register():
    """
    Compiles a shader, saves tp bpy.gl_stream[1] after refreshing the whole key-value
    """
    stream = bpy.gl_stream[SHADER_NAME]
    if stream[1] is not None:
        return #already compiled
    Desc = stream[0]

    with open(Desc.PATH_VERT, "r", encoding="utf-8") as f: 
        vert_src = f.read()
    with open(Desc.PATH_FRAG, "r", encoding="utf-8") as f:
        frag_src = f.read()
    shader = gpu.types.GPUShader(vert_src, frag_src)
    
    bpy.gl_stream[SHADER_NAME][1] = shader

def unregister():
    bpy.gl_descs.pop(SHADER_NAME)

@dataclass
class ShaderDesc:
    NAME: str
    PATH_VERT: str
    PATH_FRAG: str
    DRAW_REGION: str
    DRAW_TYPE: str
    DRAW_PRIMITIVE_METHOD:str
    CALL_UNI: Callable
    CALL_BATCH: Callable
    CALL_EXEC: Callable
    PARAMS: Type
    CALL_REG:Callable
    CALL_UNREG:Callable
DESCRIPTION = ShaderDesc(
    NAME                  =SHADER_NAME,
    PATH_VERT             =os.path.join(BASE_DIR, V),
    PATH_FRAG             =os.path.join(BASE_DIR, F),
    DRAW_REGION           = DRAW_REGION, 
    DRAW_TYPE             = DRAW_TYPE, 
    DRAW_PRIMITIVE_METHOD = DRAW_PRIMITIVE_METHOD,
    CALL_UNI              =uniforms_bind,
    CALL_BATCH            =batch_make,
    CALL_EXEC             =exec,
    PARAMS                =shader_params,
    CALL_REG              =compile_n_register,
    CALL_UNREG            =unregister
)

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\template\vert.glsl
========================================

in vec3 pos;

void main() {
    gl_Position = vec4(pos, 1.0);
}