
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\main.py
========================================


def main():
    import sys
    import importlib
    project_root = r"D:\soon\projects\PBNPR\code\bpy_glsl_manager"

    if project_root not in sys.path:
        sys.path.append(project_root)
    
    from bpy_gl import GLSLbase
    from bpy_ui import ui_tab as UI
    
    modules= [
        GLSLbase,
        UI
    ]
    for mod in modules:
        importlib.reload(mod)

    GLSLbase.register()
    UI.register()

if __name__ == "__main__":
    main()

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\bpy_gl\GLSLbase.py
========================================
import bpy

#Hot~
def load_modules()->list:
    from src.template import template as GLSL_TEMP
    from src.paint_obj import paint as GLSL_PAINT_OBJ
    from src.normals import normals as GLSL_NRMS
    
    return[
        GLSL_TEMP,
        GLSL_PAINT_OBJ,
        GLSL_NRMS
    ]

def init_stream():
    if not hasattr(
            bpy,"gl_stream"
        ):
        bpy.gl_stream = {}

def load_mods_to_stream():
    from importlib import reload
    mods = load_modules()
    for mod in mods:
        reload(mod)
        bpy.gl_stream[mod.SHADER_NAME]=[
            mod.DESCRIPTION,None
        ]

def load_shader(name:str):
    bpy.gl_stream[name][0].CALL_REG()

def register():
    init_stream()
    load_mods_to_stream()
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\bpy_ui\ui_tab.py
========================================
import bpy

ID_OP_ADD = "gl.add_instance"
ID_OP_REMOVE = "gl.remove_instance"
ID_INSTANCE_enable = "enabled"
ID_INSTANCE_expand = "expanded"

def _get_GPU():
    from bpy_gl import GLSLbase
    return GLSLbase
GPUobjs = []
# ---------------------------------------------------------
def toggle(self, context):
    GL = _get_GPU()
    GL.load_shader(self.shaderType)

    if self.enabled and self.handler_id == -1:
        i=0
        for d in bpy.context.scene.gl_stack:
            if self == d:
                self.handler_id = i
                break
            else:
                i+=1

        while GPUobjs.__len__() <= self.handler_id:
            GPUobjs.append(None)

        pair = bpy.gl_stream[self.shaderType]
        shader = pair[1]
        desc = pair[0]
        ui_spec = getattr(
            self, 
            self.shaderType, 
            None
        )

        args = (
            shader,
            desc.CALL_BATCH(shader,ui_spec),
            ui_spec
        )

        handler = bpy.types.SpaceView3D.draw_handler_add(
            desc.CALL_EXEC, args,
            desc.DRAW_REGION, desc.DRAW_TYPE
        )
        GPUobjs[self.handler_id]=handler
    
    elif not self.enabled and self.handler_id != -1:
        pair = bpy.gl_stream[self.shaderType]
        desc = pair[0]
        bpy.types.SpaceView3D.draw_handler_remove(
            GPUobjs[self.handler_id], desc.DRAW_REGION
        )
        GPUobjs[self.handler_id] = None
        self.handler_id = -1

class gl_instance_sk(bpy.types.PropertyGroup):
    shaderType: bpy.props.StringProperty(name="shader", default="")
    enabled: bpy.props.BoolProperty(default=False, update=toggle)
    expanded: bpy.props.BoolProperty(default=True)
    handler_id : bpy.props.IntProperty(default=-1)

#-------------------------------------------------------------

def get_items(self, context):
    return [(key, key, "") for key in bpy.gl_stream.keys()]
class gl_OP_add_instance(bpy.types.Operator):
    bl_idname = ID_OP_ADD
    bl_label = "Add GLSL Instance"

    selected_type: bpy.props.EnumProperty(
        name="shaders",
        items=get_items
    )

    def invoke(self, context, event):
            wm = context.window_manager
            return wm.invoke_props_dialog(self)

    def execute(self, context):
        new_i = context.scene.gl_stack.add()
        new_i.shaderType = self.selected_type
        return {'FINISHED'}

class gl_OP_remove_instance(bpy.types.Operator):
    bl_idname = ID_OP_REMOVE
    bl_label = ""
    index_i : bpy.props.IntProperty(default=-1)

    def execute(self, context):
        if self.index_i < 0:
            return {'CANCELED'}
        x = bpy.context.scene.gl_stack[self.index_i]
        x.enabled = False
        bpy.context.scene.gl_stack.remove(self.index_i)
        return {'FINISHED'}
#-------------------------------------------------------------
class gl_panel(bpy.types.Panel):
    bl_label = "GLSL"
    bl_space_type = 'VIEW_3D'
    bl_region_type = 'UI'
    bl_category = 'GLSL manager'

    def draw(self, context):
        layout = self.layout

        box = layout.box()
        row = box.row(align=True)

        row.operator(ID_OP_ADD, text="Add Instance")

        i = 0
        for item in context.scene.gl_stack:
            box = layout.box()
            row = box.row(align=True)
            
            row.prop(item, ID_INSTANCE_expand,
                icon='TRIA_DOWN' if item.expanded else 'TRIA_RIGHT',
                icon_only=True, emboss=False
            )
            row.label(text=item.shaderType, 
                icon='SHADING_RENDERED')
            row.prop(item, ID_INSTANCE_enable, text="")
            
            op_R = row.operator(ID_OP_REMOVE, 
                              text="", icon='X')
            op_R.index_i = i # Index Save

            if not item.expanded:
                continue

            custom_params = getattr(item,item.shaderType)
            for prop in custom_params.bl_rna.properties:
                row=box.row(align=True)
                row.prop(custom_params,prop.identifier)
            i+=1

classes = [
    gl_instance_sk, 
    gl_OP_add_instance,
    gl_OP_remove_instance,
    gl_panel
]

def register():
    for cls in classes:
        bpy.utils.register_class(cls)
    for pair in bpy.gl_stream.values():
        desc = pair[0]
        bpy.utils.register_class(desc.PARAMS)
        setattr(
            gl_instance_sk, desc.NAME,
            bpy.props.PointerProperty(type=desc.PARAMS)
        )
    bpy.types.Scene.gl_stack = bpy.props.CollectionProperty(type=gl_instance_sk)

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\normals\frag.glsl
========================================

out vec4 fragColor;

void main() {
    vec3 N = normalize(v_normal);
    vec3 V = normalize(uCamPos - v_world_pos);

    float rim = 1.0 - max(dot(N, V), 0.0);

    // Shape the rim
    rim = smoothstep(0.4, 1.0, rim);

    vec3 baseColor = vec3(0.6);
    vec3 rimColor  = vec3(1.0);

    fragColor = vec4(baseColor + rim * rimColor, 1.0);
}

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\normals\normals.py
========================================
import os
import bpy
import gpu
from gpu_extras.batch import batch_for_shader
from dataclasses import dataclass
from typing import Callable, Type
import numpy as np
from mathutils import Matrix

BASE_DIR = os.path.dirname(__file__)
SHADER_NAME = "NORMALS"
V = "vert.glsl"
F = "frag.glsl"
DRAW_REGION = "WINDOW"
DRAW_TYPE = "POST_VIEW"
DRAW_PRIMITIVE_METHOD = "TRIS"
# ------------------ ------------------ ----------- 
def toggle(self,context):
    img = bpy.data.images.get(self.image)
    if not img: return

    W, H = img.size
    
    pair = bpy.gl_stream[SHADER_NAME]
    desc = pair[0]
    shader = pair[1]
    batch = desc.CALL_BATCH(shader,self)
    
    offscreen = gpu.types.GPUOffScreen(W, H) 
    with offscreen.bind():
        gpu.state.viewport_set(0, 0, W, H)
        desc.CALL_EXEC(shader,batch,self)
        buffer = gpu.state.active_framebuffer_get().read_color(0, 0, W, H, 4, 0, 'FLOAT')

    buffer.dimensions = W * H * 4 
    img.pixels.foreach_set(buffer) 
    img.update() 
    
    offscreen.free() 

class shader_params(bpy.types.PropertyGroup):
    cam_name: bpy.props.StringProperty(default="Camera")
    obj_name: bpy.props.StringProperty(default="Cube")
    
    image : bpy.props.StringProperty(default="GLSL_layer",update=toggle)

def uniforms_bind(
        shader: gpu.types.GPUShader,
        block:shader_params
    ):
    shader.bind()

    
def batch_make(
        shader: gpu.types.GPUShader,
        block:shader_params, 
        drawShape: str = DRAW_PRIMITIVE_METHOD
    ):
    if block.obj_name not in bpy.data.objects:
        # Fallback 2D Triangle
        coords = np.array([
                (-0.5, -0.5, 0.0), 
                (0.5, -0.5, 0.0), 
                (0.0, 0.5, 0.0)], 
                dtype=np.float32
            )
        return batch_for_shader(shader, drawShape, {"pos": coords})
    
    deps = bpy.context.evaluated_depsgraph_get()
    obj = bpy.data.objects[block.obj_name]
    obj_eval = obj.evaluated_get(deps)
    mesh = obj_eval.to_mesh()
    mesh.calc_loop_triangles()

    # Get Vertices
    vertices = np.empty((len(mesh.vertices), 3), 'f')
    mesh.vertices.foreach_get("co", vertices.reshape(-1))

    # Get Triangle Indices (Crucial for a Cube)
    indices = np.empty((len(mesh.loop_triangles), 3), 'i')
    mesh.loop_triangles.foreach_get("vertices", indices.reshape(-1))

    
    mesh.calc_normals_split()
    normals = np.empty((len(mesh.vertices), 3), 'f')
    mesh.vertices.foreach_get("normal", normals.reshape(-1))

    obj_eval.to_mesh_clear()
    return batch_for_shader(
        shader,
        drawShape,
        {
            "pos": vertices,
            "normal": normals
        },
        indices=indices
    )

def exec(
        shader: gpu.types.GPUShader,
        batch: gpu.types.GPUBatch,
        block:shader_params
    ):
    #Provided that, shader+batch
    shader.bind()
    uniforms_bind(shader,block)
    batch.draw(shader)

#-------------------------------------

def compile_n_register():
    """
    Compiles a shader, saves tp bpy.gl_stream[1] after refreshing the whole key-value
    """
    stream = bpy.gl_stream[SHADER_NAME]
    if stream[1] is not None:
        return #already compiled
    Desc = stream[0]

    with open(Desc.PATH_VERT, "r", encoding="utf-8") as f: 
        vert_src = f.read()
    with open(Desc.PATH_FRAG, "r", encoding="utf-8") as f:
        frag_src = f.read()
    shader = gpu.types.GPUShader(vert_src, frag_src)
    
    bpy.gl_stream[SHADER_NAME][1] = shader

def unregister():
    bpy.gl_descs.pop(SHADER_NAME)

@dataclass
class ShaderDesc:
    NAME: str
    PATH_VERT: str
    PATH_FRAG: str
    DRAW_REGION: str
    DRAW_TYPE: str
    DRAW_PRIMITIVE_METHOD:str
    CALL_UNI: Callable
    CALL_BATCH: Callable
    CALL_EXEC: Callable
    PARAMS: Type
    CALL_REG:Callable
    CALL_UNREG:Callable
DESCRIPTION = ShaderDesc(
    NAME                  =SHADER_NAME,
    PATH_VERT             =os.path.join(BASE_DIR, V),
    PATH_FRAG             =os.path.join(BASE_DIR, F),
    DRAW_REGION           = DRAW_REGION, 
    DRAW_TYPE             = DRAW_TYPE, 
    DRAW_PRIMITIVE_METHOD = DRAW_PRIMITIVE_METHOD,
    CALL_UNI              =uniforms_bind,
    CALL_BATCH            =batch_make,
    CALL_EXEC             =exec,
    PARAMS                =shader_params,
    CALL_REG              =compile_n_register,
    CALL_UNREG            =unregister
)

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\normals\vert.glsl
========================================
in vec3 pos;
in vec3 normal;


void main() {
    
}

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\paint_obj\frag.glsl
========================================
in vec3 v_world_pos;

uniform vec4 uColor;
uniform float uLight;
uniform vec3 uLightPos;


void main() {
    float d = distance(v_world_pos, uLightPos);
    
    // Example: Make it darker as it gets further away
    float intensity = 1.0 / (d * d + 1.0); 
    gl_FragColor = uColor*intensity*uLight;
}
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\paint_obj\paint.py
========================================
import os
import bpy
import gpu
from gpu_extras.batch import batch_for_shader
from dataclasses import dataclass
from typing import Callable, Type
import numpy as np
from mathutils import Matrix

BASE_DIR = os.path.dirname(__file__)
SHADER_NAME = "PAINT_OBJ"
V = "vert.glsl"
F = "frag.glsl"
DRAW_REGION = "WINDOW"
DRAW_TYPE = "POST_VIEW"
DRAW_PRIMITIVE_METHOD = "TRIS"
# ------------------ ------------------ ----------- 
def toggle(self,context):
    img = bpy.data.images.get(self.image)
    if not img: return

    W, H = img.size
    
    pair = bpy.gl_stream[SHADER_NAME]
    desc = pair[0]
    shader = pair[1]
    batch = desc.CALL_BATCH(shader,self)
    
    offscreen = gpu.types.GPUOffScreen(W, H) 
    with offscreen.bind():
        gpu.state.viewport_set(0, 0, W, H)
        desc.CALL_EXEC(shader,batch,self)
        buffer = gpu.state.active_framebuffer_get().read_color(0, 0, W, H, 4, 0, 'FLOAT')

    buffer.dimensions = W * H * 4 
    img.pixels.foreach_set(buffer) 
    img.update() 
    
    offscreen.free() 

class shader_params(bpy.types.PropertyGroup):
    cam_name: bpy.props.StringProperty(default="Camera")
    obj_name: bpy.props.StringProperty(default="Cube")
    Point_name: bpy.props.StringProperty(default="Point")
    color: bpy.props.FloatVectorProperty( 
        name="Color", 
        subtype='COLOR', 
        size=4, min=0.0, max=1.0, 
        default=(0.2, 0.6, 1.0, 1.0) 
        ) 
    image : bpy.props.StringProperty(default="GLSL_layer",update=toggle)

def uniforms_bind(
        shader: gpu.types.GPUShader,
        block:shader_params
    ):
    shader.bind()

    dep = bpy.context.evaluated_depsgraph_get() 
    obj = bpy.data.objects[block.obj_name]
    obj_eval = obj.evaluated_get(dep)
    cam = bpy.data.objects[block.cam_name]

    matObj = obj_eval.matrix_world
    matCam = cam.matrix_world.inverted()

    # Projection Matrix logic
    width  = bpy.context.region.width if bpy.context.region else 1.0
    height = bpy.context.region.height if bpy.context.region else 1.0
    proj   = cam.calc_matrix_camera(dep, x=width, y=height)

    shader.uniform_float("uModel", matObj)
    shader.uniform_float("uView",  matCam)
    shader.uniform_float("uProj",  proj)
    
    obj_eval.to_mesh_clear()
    #PointLight-----------------------------------------------------------------
    shader.uniform_float("uLight", bpy.data.lights[block.Point_name].energy)
    shader.uniform_float("uLightPos", bpy.data.objects[block.Point_name].location)
    #col -----------------------------------------------------------------------
    x = [block.color[0], block.color[1], block.color[2], block.color[3]]
    shader.uniform_float("uColor", x)
    
def batch_make(
        shader: gpu.types.GPUShader,
        block:shader_params, 
        drawShape: str = DRAW_PRIMITIVE_METHOD
    ):
    if block.obj_name not in bpy.data.objects:
        # Fallback 2D Triangle
        coords = np.array([
                (-0.5, -0.5, 0.0), 
                (0.5, -0.5, 0.0), 
                (0.0, 0.5, 0.0)], 
                dtype=np.float32
            )
        return batch_for_shader(shader, drawShape, {"pos": coords})
    
    deps = bpy.context.evaluated_depsgraph_get()
    obj = bpy.data.objects[block.obj_name]
    obj_eval = obj.evaluated_get(deps)
    mesh = obj_eval.to_mesh()
    mesh.calc_loop_triangles()

    # Get Vertices
    vertices = np.empty((len(mesh.vertices), 3), 'f')
    mesh.vertices.foreach_get("co", vertices.reshape(-1))

    # Get Triangle Indices (Crucial for a Cube)
    indices = np.empty((len(mesh.loop_triangles), 3), 'i')
    mesh.loop_triangles.foreach_get("vertices", indices.reshape(-1))

    obj_eval.to_mesh_clear()
    
    # Pass both pos and indices to the batch
    return batch_for_shader(shader, drawShape, {"pos": vertices}, indices=indices)

def exec(
        shader: gpu.types.GPUShader,
        batch: gpu.types.GPUBatch,
        block:shader_params
    ):
    #Provided that, shader+batch
    shader.bind()
    uniforms_bind(shader,block)
    batch.draw(shader)

#-------------------------------------

def compile_n_register():
    """
    Compiles a shader, saves tp bpy.gl_stream[1] after refreshing the whole key-value
    """
    stream = bpy.gl_stream[SHADER_NAME]
    if stream[1] is not None:
        return #already compiled
    Desc = stream[0]

    with open(Desc.PATH_VERT, "r", encoding="utf-8") as f: 
        vert_src = f.read()
    with open(Desc.PATH_FRAG, "r", encoding="utf-8") as f:
        frag_src = f.read()
    shader = gpu.types.GPUShader(vert_src, frag_src)
    
    bpy.gl_stream[SHADER_NAME][1] = shader

def unregister():
    bpy.gl_descs.pop(SHADER_NAME)

@dataclass
class ShaderDesc:
    NAME: str
    PATH_VERT: str
    PATH_FRAG: str
    DRAW_REGION: str
    DRAW_TYPE: str
    DRAW_PRIMITIVE_METHOD:str
    CALL_UNI: Callable
    CALL_BATCH: Callable
    CALL_EXEC: Callable
    PARAMS: Type
    CALL_REG:Callable
    CALL_UNREG:Callable
DESCRIPTION = ShaderDesc(
    NAME                  =SHADER_NAME,
    PATH_VERT             =os.path.join(BASE_DIR, V),
    PATH_FRAG             =os.path.join(BASE_DIR, F),
    DRAW_REGION           = DRAW_REGION, 
    DRAW_TYPE             = DRAW_TYPE, 
    DRAW_PRIMITIVE_METHOD = DRAW_PRIMITIVE_METHOD,
    CALL_UNI              =uniforms_bind,
    CALL_BATCH            =batch_make,
    CALL_EXEC             =exec,
    PARAMS                =shader_params,
    CALL_REG              =compile_n_register,
    CALL_UNREG            =unregister
)

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\paint_obj\vert.glsl
========================================
in vec3 pos;
uniform mat4 uModel;
uniform mat4 uView;
uniform mat4 uProj;

out vec3 v_world_pos; // Send this to fragment shader

void main() {
    vec4 world_pos = uModel * vec4(pos, 1.0);
    v_world_pos = world_pos.xyz;
    
    gl_Position = uProj * uView * world_pos;
}
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\template\frag.glsl
========================================
uniform float u_f;
out vec4 fragCol;

void main() {
    vec3 F = vec3(u_f);
    fragCol = vec4(F, 1.0);
}
========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\template\template.py
========================================
import os
import bpy
import gpu
from gpu_extras.batch import batch_for_shader
from dataclasses import dataclass
from typing import Callable, Type

BASE_DIR = os.path.dirname(__file__)
SHADER_NAME = "TEMPLATE"
V = "vert.glsl"
F = "frag.glsl"
DRAW_REGION = "WINDOW"
DRAW_TYPE = "POST_VIEW"
DRAW_PRIMITIVE_METHOD = "TRIS"
# ------------------ ------------------ -----------

def toggle(self,context):
    img = bpy.data.images.get(self.image)
    if not img: return

    W, H = img.size
    
    pair = bpy.gl_stream[SHADER_NAME]
    desc = pair[0]
    shader = pair[1]
    batch = desc.CALL_BATCH(shader,self)
    
    offscreen = gpu.types.GPUOffScreen(W, H) 
    with offscreen.bind():
        gpu.state.viewport_set(0, 0, W, H)
        desc.CALL_EXEC(shader,batch,self)
        buffer = gpu.state.active_framebuffer_get().read_color(0, 0, W, H, 4, 0, 'FLOAT')

    buffer.dimensions = W * H * 4 
    img.pixels.foreach_set(buffer) 
    img.update() 
    
    offscreen.free() 
class shader_params(bpy.types.PropertyGroup):
    intensity: bpy.props.FloatProperty(default=1.0)
    image : bpy.props.StringProperty(default="GLSL_layer",update=toggle) #Bake on update the name

def uniforms_bind(
        shader: gpu.types.GPUShader,
        block:shader_params
    ):
    shader.bind()
    shader.uniform_float("u_f", block.intensity)

def batch_make(
        shader: gpu.types.GPUShader,
        block:shader_params, 
        drawShape: str = DRAW_PRIMITIVE_METHOD
    ):
    coords = [ 
        (-0.5, -0.5), 
        ( 0.5, -0.5), 
        ( 0.0, 0.5)
        ]
    return batch_for_shader(shader, drawShape, {"pos": coords})

def exec(
        shader: gpu.types.GPUShader,
        batch: gpu.types.GPUBatch,
        block:shader_params
    ):
    #Provided that, shader+batch
    shader.bind()
    uniforms_bind(shader,block)
    batch.draw(shader)

#-------------------------------------

def compile_n_register():
    """
    Compiles a shader, saves tp bpy.gl_stream[1] after refreshing the whole key-value
    """
    stream = bpy.gl_stream[SHADER_NAME]
    if stream[1] is not None:
        return #already compiled
    Desc = stream[0]

    with open(Desc.PATH_VERT, "r", encoding="utf-8") as f: 
        vert_src = f.read()
    with open(Desc.PATH_FRAG, "r", encoding="utf-8") as f:
        frag_src = f.read()
    shader = gpu.types.GPUShader(vert_src, frag_src)
    
    bpy.gl_stream[SHADER_NAME][1] = shader

def unregister():
    bpy.gl_descs.pop(SHADER_NAME)

@dataclass
class ShaderDesc:
    NAME: str
    PATH_VERT: str
    PATH_FRAG: str
    DRAW_REGION: str
    DRAW_TYPE: str
    DRAW_PRIMITIVE_METHOD:str
    CALL_UNI: Callable
    CALL_BATCH: Callable
    CALL_EXEC: Callable
    PARAMS: Type
    CALL_REG:Callable
    CALL_UNREG:Callable
DESCRIPTION = ShaderDesc(
    NAME                  =SHADER_NAME,
    PATH_VERT             =os.path.join(BASE_DIR, V),
    PATH_FRAG             =os.path.join(BASE_DIR, F),
    DRAW_REGION           = DRAW_REGION, 
    DRAW_TYPE             = DRAW_TYPE, 
    DRAW_PRIMITIVE_METHOD = DRAW_PRIMITIVE_METHOD,
    CALL_UNI              =uniforms_bind,
    CALL_BATCH            =batch_make,
    CALL_EXEC             =exec,
    PARAMS                =shader_params,
    CALL_REG              =compile_n_register,
    CALL_UNREG            =unregister
)

========================================
D:\soon\projects\PBNPR\code\bpy_glsl_manager\src\template\vert.glsl
========================================

in vec3 pos;

void main() {
    gl_Position = vec4(pos, 1.0);
}